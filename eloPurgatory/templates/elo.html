{% extends "search.html" %}

{% block elo %}
{% load static %}
<script src="{% static 'd3.js' %}" type="text/javascript"></script>

<form id="matchlist">
<ul>
{% for matchId, matchData in matchlist.items %}
    <li><input name="matchId" id={{matchId}} type="checkbox" checked>
    <a href="http://matchhistory.{{region}}.leagueoflegends.com/en/#match-details/{{platform}}/{{matchId}}/{{summoner.summonerId}}">{{ matchId }}</a>
    <ul>
    {% for playerId, playerData in matchData.players.items %}
        <li>{{ playerData.rank.summoner.name }}:{{ playerData.rank.tier }} {{ playerData.rank.division }}</li>
    {% endfor %}
    </ul>
    </li>
{% endfor %}
</ul>
<input type="button" onclick="drawRankDistroChart(rankHandler())">
</form>

{% for tier, tierPNG in tier_icons.items %}
    {% if tier != "UNRANKED" %}    
    <img src="{% static tierPNG %}" width=200 height=200>
    {% endif %}
{% endfor %}

<script>
var matches = {{data|safe}};
var tiers = ["UNRANKED", "BRONZE", "SILVER", "GOLD", "PLATINUM", "DIAMOND", "MASTER", "CHALLENGER"];
drawRankDistroChart(rankHandler());

function rankHandler() {
    var rankCount = { };

    for (index in tiers) {
        var tier = tiers[index];
        if (tier == "UNRANKED" ) {
            rankCount[tier] = 0;
        } else if (tier == "MASTER" || tier == "CHALLENGER") {
            rankCount[tier] = [];
        } else {
            rankCount[tier] = { V   : 0,
                                IV  : 0,
                                III : 0,
                                II  : 0,
                                I   : 0, };
        }
    }
    
    for (matchId in matches) {
        if (!(document.getElementById(matchId).checked)) {
            continue;
        }
        var matchData = matches[matchId];
        var players = matchData.players;
        for (playerId in players) {
            playerData = players[playerId];
            if (playerData.rank.tier == "UNRANKED") {
                rankCount[playerData.rank.tier]++;
            } else if (playerData.rank.tier == "CHALLENGER" || playerData.rank.tier == "MASTER") {
                rankCount[playerData.rank.tier].append(playerData.rank.division);
            } else {
                rankCount[playerData.rank.tier][playerData.rank.division]++;
            }
        }
    }

    var dataset = [];
    for (tier in rankCount) {
        if (tier == "UNRANKED" || tier == "MASTER" || tier == "CHALLENGER")) {
            continue;
        } else {
            for (division in rankCount[tier]) {
                dataset.push(rankCount[tier][division]);
            }        
        }
    }       

    //handleMasterChallenger(rankCount["MASTER"], 5);
    //handleMasterChallenger(rankCount["CHALLENGER"], 5);

    return dataset;
}

function handleMasterChallenger(dataset, blocks, lower) {
    var result = {};
    if (dataset.length > 0) {
        dataset.sort(function(a,b){return a-b});
        var blockIndex = 1;
        var range = dataset[dataset.length-1] - lower;
        var higher = lower + Math.round(range * blockIndex / blocks);
        var blockTotal = 0;
        for (i = 0; i < dataset.length; i++) {
            if (dataset[i] <= higher) {
                blockTotal++;
            } else {
                result[lower.toString() + "-" + higher.toString()] = blockTotal;
                blockTotal = 0;
                blockIndex++;
                lower = higher++;
                higher = lower + Math.round(range * blockIndex / blocks);
            }
        }
    }
    return result;
}

function drawRankDistroChart(dataset) {
    d3.select("body").select("svg").remove();
    var padding = 1;
    var w = 1400;
    var h = 600;
    var svg = d3.select("body")
                .append("svg")
                .attr("width", w)
                .attr("height", h);
    for (tier in dataset) {
        var numValues = [];
        var textValues = []
        if (tier == "UNRANKED" || tier == "MASTER" || tier == "CHALLENGER") {
            continue;
        } else {
            for (division in dataset[tier]) {
                numValues.append(dataset[tier][division]);
                textValues.append(division);
            }
        }
        svg.selectAll("rect").data(numValues)
                            .enter()
                            .append("rect")
                            .attr("x", function(d, i) {
                                return i * (w / dataset.length);
                             })
                            .attr("y", function(d) {
                                return h - d * 20;
                            })
                            .attr("width", w / dataset.length - padding)
                            .attr("height", function(d) {
                                return d * 20;
                            })
                            .attr("fill" , function(d) {
                                return "rgb(0, 0, " + (d * 20) + ")";
                            });

        svg.selectAll("text").data(numValues)
                             .enter()
                             .append("text")
                             .text(function(d) {
                                return d;
                             })
                             .attr("x", function(d, i) {
                                return i * (w / dataset.length) + 10 ;
                             })
                             .attr("y", function(d) {
                                return h - (d * 10) + 20;
                             })
                             .attr("text-anchor", "middle")
                             .attr("fill", "white");

        svg.selectAll("text").data(textValues)
                             .enter()
                             .append("text")
                             .text(function(d) {
                                return d;
                             })
                             .attr("x", function(d, i) {
                                return i * (w / dataset.length) + 10;
                             })
                             .attr("y", function(d) {
                                return h - (d * 10) + 20;
                             }) 
                             .attr("text-anchor", "middle")
                             .attr("fill", "white");                                                                                                                                                                                                                                         
    }
}

</script>
{% endblock %}
